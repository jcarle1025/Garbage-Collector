#include "myalloc.h"#define _GNU_SOURCE#include <stdio.h>#include <assert.h>#include <signal.h>void *myalloc2(int size);void coalesce();void mark(int *p);void sweep();int *isPtr(int *p);int blockMarked(int *p);void markBlock(int *p);void unmarkBlock(int *p);int blockAllocated(int *p);void allocateBlock(int *p);void unallocateBlock(int *p);int length(int *p);int *nextBlock(int *p);int *start;void myallocinit(int size) {     	int blocklen = ((size + 3) / 8 + 1) * 8;	start = (int *)malloc(blocklen + 8);	if (start == NULL) {		printf("Cannot init that much space\n");		exit(1);	}	start ++;	*start = blocklen;	printf("Initialized heap at %u ", start);	if(blockAllocated(start))		printf("is allocated ");	else {printf("is unallocated ");}	printf("with size: %d\n", length(start));	*(nextBlock(start)) = 1; 	if(blockAllocated(nextBlock(start)))		printf("Sentinel is allocated and set to %d\n\n", length(nextBlock(start)));}void printallocation() {	int *ptr = start;		while(length(ptr) != 0){		printf("Block starting at %u ", ptr+1);				if(blockAllocated(ptr))			printf("is allocated ");		else 			printf("is unallocated ");					printf("with size: %d\n", length(ptr));		ptr = nextBlock(ptr);	}	printf("\n");}void * myalloc(int size) {	void *mptr = myalloc2(size);	if((int*)mptr != NULL){		printf("mallocing...\n");		return mptr; 	}		else if((int*)mptr == NULL){		printf("Cannot Allocate that much Space\n");		coalesce();		return NULL;	}}void * myalloc2(int size) {	int newsize = ((size+3) / 8 + 1) * 8;	int *ptr = start;	int *newptr, firstLen; 	int *end = start;	int wholeSize = length(start);		while(length(end) != 0){		end = nextBlock(end);		wholeSize+=length(end);	}	end = start+wholeSize/4; 		while(length(ptr) != 0 && ptr < end){		if(!blockAllocated(ptr)){			firstLen = length(ptr);						*ptr = newsize;			allocateBlock(ptr);				newptr = nextBlock(ptr);			*newptr = firstLen - length(ptr);						unallocateBlock(newptr);					return ptr+1;		}		ptr = nextBlock(ptr);	}	return NULL;}void myfree(void *p) {	int *controlWord = p-4;	printf("freeing...\n");	unallocateBlock(controlWord);	coalesce();}void coalesce() {	int *ptr = start;	int *nextptr = nextBlock(ptr);	int *p2 = nextptr;		while(length(nextptr) != 0){		if(!blockAllocated(ptr) && !blockAllocated(nextptr)){			nextptr = nextBlock(p2);			*ptr = length(ptr)+length(p2);			p2 = nextptr;		}				else{			ptr = nextBlock(ptr);			nextptr = nextBlock(nextptr);			p2 = nextptr;		}	}} void mygc() {	unsigned long stack_bottom;	int **max =  (int **) GC_init(); 	int *q;	int **p = &q; 	while (p < max) {//iterate through stack		mark(*p);		p++;	}  	sweep();  	coalesce();}void mark(int *p) { 	int *ptr, *next;	ptr = isPtr(p);		if(ptr == NULL)		return;	if(blockMarked(ptr-1)==2)		return;	markBlock(ptr-1);	next = nextBlock(ptr-1);		while(next > ptr){//iterate through heap 		mark(ptr);		ptr ++;	}}void sweep() { 	int *ptr = start;	while(length(ptr)!=0){		if(blockMarked(ptr)==2){			unmarkBlock(ptr);			printf("Just unmarked\n");		}		else {			if(blockAllocated(ptr)){				myfree(ptr+1);			}		}		ptr = nextBlock(ptr);	}}int *isPtr(int *p) {	int *myLast;		myLast = start;	while(length(myLast)!=0){		myLast = nextBlock(myLast);	}		if(start <= p && p < myLast && blockAllocated(p-1))		return p;	return NULL;	}int blockMarked(int *p) {	return *p & 1<<1;}void markBlock(int *p) {	*p = *p | 1<<1;}void unmarkBlock(int *p) {	*p = *p & ~(1<<1);}int blockAllocated(int *p) {	return *p & 1<<0;}void allocateBlock(int *p) {	*p = *p | 1;}void unallocateBlock(int *p) {	*p = *p & ~(1<<0);}int *nextBlock(int *p) {	int *next;	next = p + length(p)/4;	return next;}int length(int *p) {	int val;	val = *p;	val = (val/8)*8;	return val;}